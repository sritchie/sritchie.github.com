#+STARTUP: showall indent
#+STARTUP: hidestars
#+BEGIN_HTML
---
layout: post
title: Testing Cascalog with Midje
---

<p class="meta">27 Sept 2011 - San Francisco</p>
#+END_HTML

* Testing Cascalog with Midje

One of the most exciting advantages Cascalog holds over Pig and Hive is its expressive power; Clojure is truly a wonder in that regard. One particular problem with other current MapReduce abstraction layers is the utter difficulty of testing queries and workflows. End-to-end tests are maddening to craft in pure MapReduce and frustrating at best in Pig and Hive.

I've been working on a Cascalog testing suite these past few weeks, an extension to Brian Marick's Midje, that solves the problems of testing MapReduce workflows.

** Functional MapReduce Testing

I'll start with an example cascalog query:

#+begin_src clojure
  (defn max-followers-query [datastore-path]
    (let [src (name-vars (complex-subquery datastore-path)
                         ["?user" "?followers"])]
      (c/first-n src 1 :sort ["?followers"] :reverse true)))
#+end_src

=complex-subquery= generates 2-tuples of the form =[user, follower-count]=. =max-followers-query= is only responsible for pulling the tuples with the most =?followers=.

Let's pretend that you were writing this in MapReduce. How would you run tests against this job?

- MapReduce jobs require a specific FileInputFormat, so you'd start by creating a temporary directory, serializing some test data and passing it into a tempfile in the proper InputFormat.
- Next, execute the job on that tempfile and funnel its results into another temp directory.
- Extract each k-v pair, deserialize and run the results through your test code
- destroy temporary files and directories.

Any test of application logic is dwarfed by the maintenance required. Most real world MapReduce applications involved chained jobs, a nightmare to test using the above methods. Perhaps for this reason, [[http://www.cloudera.com/blog/2009/07/debugging-mapreduce-programs-with-mrunit/][Cloudera]] recommends testing mappers and reducers separately, one tuple at a time:

#+begin_quote
/many errors can be quickly identified with small tests involving a single, well-chosen input record./
#+end_quote

This is insane. Imagine writing a complex function responsible for heavy IO, and testing an internal for-loop with one well-chosen integer.

A well designed testing suite will test each MapReduce query against a range of input data, in addition to testing full flows and compositions of queries.

With Midje (and my extension, [[https://github.com/sritchie/midje-cascalog][midje-cascalog]]), you can obliterate the complexity of testing =max-followers-query= by mocking out the result of =complex-subquery=  to return a Clojure data structure:

#+begin_src clojure
  (fact?- "Query should return 1 tuple with the most popular user +
          follower count."
          [["richhickey" 2961]]
          (max-followers-query :path)
          (provided
            (complex-subquery :path) => [["sritchie09" 180]
                                         ["richhickey" 2961]]))
  
#+end_src

This test, or "fact", states that

- when =max-followers-query= is called with the argument =:path=,
- it will produce =[ [ richhickey" 2961] ]=,
- Provided =(complex-subquery :path)= produces =[["sritchie09" 180] ["richhickey" 2961]]=.

The application logic here is completely separate from filesystem IO. The test examines a single query, and proves it to be correct for all expected inputs. Tests like this are the building blocks of rock-solid production apps.

Midje gives you the power to test logical units of MapReduce code with full freedom from filesystem details, a feat unprecedented in the big data world. Let's get an example project set up and do some testing.

** Setting Up your Environment

*** Midje

Midje is an incredible testing framework by Brian Marick. It supports a number of [[https://github.com/marick/Midje/wiki/Checkers-for-collections-and-strings][collection checkers]], and allows for intuitive mocking of clojure functions and vars. I've extended Midje with [[https://github.com/sritchie/midje-cascalog][a few macros]] that mirror cascalog's query execution syntax: =fact?-= vs =?-=, =fact?<-= vs =?<-=.

*** Example Project

You can find all source code from this post [[https://github.com/sritchie/cascalog-testing-demo][on github]]. To add =midje-cascalog= support to your own project, add these entries to =:dev-dependencies=:

#+begin_src clojure
[lein-midje "1.0.3"]
[midje-cascalog "0.2.0"]
#+end_src
 
** Cascalog Queries

Let's start by fleshing out word counting in Cascalog.

#+begin_src clojure
  (ns cascalog.testing-demo.core
    (:use cascalog.api)
    (:require [cascalog.ops :as c])
    (:gen-class))
    
  (defmapcatop split
    "Accepts a sentence, splits on whitespace, and emits a single
    1-tuple for each word."
    [^String sentence]
    (seq (.split sentence "\\s+")))
  
  (defn wc-query
    "Returns a subquery that generates wordcounts for every word in
      the textfiles located at `text-path`."
    [text-path]
    (let [src (hfs-textline text-path)]
      (<- [?word ?count]
          (src ?textline)
          (split ?textline :> ?word)
          (c/count ?count))))
    
  (defn -main
    "Accepts a path to a number of text files and a results path, and
     prints each distinct word along with its count to an `hfs-textline`
     tap at `results-path`."
    [text-path results-path]
    (?- (hfs-textline results-path)
        (wc-query text-path)))
#+end_src

=wc-query= takes a path to some directory containing textfiles, and returns a query that produces =[word count]= pairs. =-main= executes this query into another textfile.

The project's application logic lies in =wc-query=. Testing =wc-query= in isolation is difficult, as =wc-query= takes a path meant for =hfs-textline=, rather than accepting a tuple source directly. How can we test this, without rewriting the query?

The solution lies in Midje's mocking support. Let's build up to this by going over some basic fact-based cascalog tests.

** Basic Cascalog Testing

Let's put our tests in =./test/cascalog/testing_demo/core_test.clj= (mirroring the =core.clj=, with =_test= tacked on):

#+begin_src clojure
  (ns cascalog.testing-demo.core-test
    (:use cascalog.testing-demo.core
          cascalog.api
          [midje sweet cascalog])
    (:require [cascalog.ops :as c]))
#+end_src

*** fact?- 

=fact?-= accepts pairs of result-tuple-sequences and queries:

#+begin_src clojure
  (fact?- [[1 2]] (<- [?a ?b]
                      ([[1]] ?a)
                      (inc ?a :> ?b))
  
          [[3 4]] (<- [?a ?b]
                      ([[4]] ?b)
                      (dec ?b :> ?a)))
#+end_src

The above code states two distinct "facts" about our data. Each query (on the right), when executed, produces the sequence of tuples (to its left). Ordering of result tuples doesn't matter.

The following form is also valid:

#+begin_src clojure
  (defn some-query [src]
    (<- [?a ?b]
        (src ?a)
        (inc ?a :> ?b)))
  
  (fact?- :info
          "Strings are fine anywhere!"
          [[1 2]] (some-query [[1]]))
#+end_src

The first keyword sets a custom log level; in the absence of this keyword. The log level defaults to =:fatal=. (See [[https://github.com/nathanmarz/cascalog/blob/master/src/clj/cascalog/io.clj#L59][cascalog.util]] for all other options).

*** fact?<- 

=fact?<-= is analogous to =?<-=, in that it defines single query and tests it within the same form.

#+begin_src clojure
(fact?<- [[1 2]]
         [?a ?b]
         ([[1]] ?a)
         (inc ?a :> ?b))
#+end_src

This fact defines a query that produces 2-tuples of the form =[?a ?b]=, and tests that it generates =[ [1 2] ]= on execution.

I find =fact?<-= useful mostly for testing how =def*op= functions behave inside of queries. =fact?-= is broadly useful for testing full queries and workflows, and shows up in far more tests.

*** future-fact?- and future-fact?<-

If you want to stub out an unfinished test, use any of the following in place of the two macros above:

- =future-fact?-= and =future-fact?<-=
- =pending-fact?-= and =pending-fact?<-=

This will prevent the body of the fact from being evaluated. (The =future-fact= and =pending-fact= forms are identical. Midje provides [[https://github.com/marick/Midje/wiki/Future-facts][more information here]].)

*** lein-midje

Once you write all these tests, how to run them? If you're using leiningen, add =[lein-midje "1.0.3"]= to your =project.clj=, and run =lein midje= in your project directory. This will run all facts and tests in the project and print a summary of results to stdout. (Here's the [[https://github.com/marick/Midje/wiki/Lein-midje][github page]] for lein-midje.)

*** Interaction with clojure.test

If you're currently using clojure.test, check out [[https://github.com/marick/Midje/wiki/Migrating-from-clojure.test][Midje's tips]] on integration. The two modes work very well together. =lein midje= will evaulate all =deftest= forms inside of a project, and include the results in its report.

** Mocking

Let's revisit =wc-query= from =cascalog.testing-demo.core=. Here's an initial test, mocked out with =fact?-=:

#+begin_src clojure
  (fact?- "wc-query should count words from all lines of text at
          /path/to/textfile."
          result-vec (wc-query "/path/to/textfile"))
#+end_src

=wc-query=, as written, performs an internal call to =hfs-textline=. =hfs-textline= provides with tuples from the filesystem, and as such has no direct place in our logic tests.

*** provided 

Mocking allows us to intercept all calls to =hfs-textline= and insert our own tuples. Using midje's =provided= form, this looks like:

#+begin_src clojure
  (def short-sentences
    [["this is a sentence sentence"]
     ["sentence with this is repeated"]])
  
  (def short-wordcounts
    [["sentence" 3]
     ["repeated" 1]
     ["is" 2]
     ["a" 1]
     ["this" 2]
     ["with" 1]])
  
  (fact?- "fact?- accepts `result-vec, query` pairs."
          short-wordcounts (wc-query :text-path)
          (provided
            (hfs-textline :text-path) => short-sentences))
#+end_src

This fact states that 

- when =wc-query= is called with =:text-path=
- it will produce =short-sentences=,
- Provided =(hfs-textline :text-path)= produces =short-wordcounts=.

=provided= forms only apply to the queries directly above. This won't work, as the first pair can't access the second pair's =provided= block:

#+begin_src clojure
  (fact?- results (some-query :a) ;; provided call won't apply here!
          
          results-2 (another-query :a) ;; only here.
          (provided
            (inner-func :a) => 10))
#+end_src

*** Nested Mocking

=(provided ... )= can also mock nested calls, as discussed [[https://github.com/marick/Midje/wiki/Folded-prerequisites][here]]. For example:

#+begin_src clojure
  (fact?- results (query :arg :arg2)
          (provided (f1 (f2 :arg)) => source-tuples
                    (f3 :arg2) => other-src))
#+end_src

This fact mocks out calls to =(f3 :arg2)= and =(f1 (f2 :arg1))=, and expects that both will show up somewhere within the body of =(query :arg :arg2)=.

I prefer keywords as mocking arguments, but strings, numbers, and any symbol surrounded by dots (like =..this..=) are all valid.

*** against-background

As discussed, the =provided= keyword only applies to the fact-pair directly above. it. As =fact?-= takes multiple forms, this can be limiting; What if you want to mock a function's results for all forms?

Midje solves this with =against-background=. Functions mocked within this form have lower precedence than =provided= mocking, but apply to all queries, as shown here:

#+begin_src clojure
  (fact?- "Same test as before, pulling mocking from against-background
          below."
          short-wordcounts
          (wc-query :text-path)
          
          "provided overrides against-background for the query directly
          above it."
          [["what" 1] ["a" 1] ["world!" 1]]
          (wc-query :text-path)
          (provided
            (hfs-textline :text-path) => [["what a world!"]])
          
          (against-background
            (hfs-textline :text-path) => short-sentences))
#+end_src

This power allows you to explore a range of query edge cases with a single mock.

** Collection Checkers

Executed queries return collections of data. =wc-query= will produce a rather large sequence of =<word, count>= pairs for a small number of input sentences. This is no reason to limit tests to small sentences!

Midje provides a range of collection checkers that provide you with finer control. (All collection checker options are documented [[https://github.com/marick/Midje/wiki/Checkers-for-collections-and-strings][here]].)

*** just

This is the default checker for =midje-cascalog=. Bare result vectors resolve to =(just result-vec :in-any-order)=. The following two facts are eqivalent:

#+begin_src clojure
(fact?- (just [[2 3] [1 2]] :in-any-order)
        (<- [?a ?b]
            ([[1] [2]] ?a)
            (inc ?a :> ?b))

        [[2 3] [1 2]]
        (<- [?a ?b]
            ([[1] [2]] ?a)
            (inc ?a :> ?b)))
#+end_src

Each of these facts checks that its subquery returns =[2 3]= =[1 2]= exclusively, in any order.

For the next set of facts, let's introduce a larger set of input sentences:

#+begin_src clojure
  (def longer-sentences
    [["Call me Ishmael. Some years ago -- never mind how long"]
     ["precisely -- having little or no money in my purse, and"]
     ["nothing particular to interest me on shore, I thought I"]
     ["would sail about a little and see the watery part of the world."]])
#+end_src

*** contains

The =contains= form, used as =(contains result-vec)=, tests that =result-vec= occurs, in order, somewhere within a query's results. The tuples in =result-vec= must be contiguous. (Using =contains= by itself really only make sense when querying for the top-n on some field, where the ordering is what's important.)

Adding the =:gaps-ok= keyword at the end of the form relaxes the contiguous requirement. Adding =:in-any-order=, or using a set for =result-vec=, relaxes the ordering restriction. For example:

#+begin_src clojure
  (fact?- (contains #{["sail" 1] ["Ishmael." 1]} :gaps-ok)
          (wc-query :text-path)
          (provided
            (hfs-textline :text-path) => longer-sentences))
#+end_src

The above fact tests that both =["sail" 1]= and =["Ishmael." 1]= appear somewhere in the results, in any order. (Note the set wrapping the result tuples.)

*** has-prefix

=has-prefix= checks that the supplied result vector occurs at the very beginning of the query's results. Like =contains= when used without keyword arguments, =has-prefix= only makes sense with queries that return sorted tuples.

The following fact checks that =["--" 2]=, =["I" 2]= and =["and" 2]= are the top three words (by count) across all words in =longer-sentences=:

#+begin_src clojure
  (fact?- (has-prefix [["--" 2] ["I" 2] ["and" 2]])
          (-> (wc-query :text-path)
              (c/first-n 10 :sort ["?count"] :reverse true))
          (provided
            (hfs-textline :text-path) => longer-sentences))
#+end_src

*** has-suffix

*** has

** Tabular

** In Conclusion
CONCLUSION!
